/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./dev/static/js/index.js":
/*!********************************!*\
  !*** ./dev/static/js/index.js ***!
  \********************************/
/***/ (() => {

eval("// import {\n//     CubeTextureLoader,\n//     Scene,\n//     WebGLRenderer,\n//     WebGLRenderTarget,\n//     SpotLight, \n//     PointLight,\n//     AxesHelper,\n//     AnimationMixer,\n//     HalfFloatType,\n//     HemisphereLight,\n//     Clock,\n//     ShaderMaterial,\n//     Uniform,\n//     Color,\n//     Vector2,\n//     CubeTexture,\n//     TextureLoader,\n// } from 'three';\n// import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';\n// const maxScrollHeight = ($(window).height() * 11);\n// const canvasPlaceSelector = document.querySelector('[data-hero-canvas-place]');\n// const scene = new Scene()\n// // scene.add(new AxesHelper(5))\n// const light = new SpotLight()\n// light.position.set(5, 5, 5)\n// scene.add(light);\n// const themeDir = document.body.dataset.themeDir;\n// let perspectiveCamera;\n// const mainRenderer = new WebGLRenderer({ \n//     antialias: true,\n//     alphaToCoverage: true,\n// })\n// mainRenderer.setSize(window.innerWidth, window.innerHeight);\n// canvasPlaceSelector?.appendChild(mainRenderer.domElement);\n// const guiOptions = {\n//   refractionIndex: 1,\n//   color: \"#FFFFFF\",\n//   dispersion: 0.1,\n//   roughness: 0.9,\n//   animation: true,\n// };\n// const renderTarget = new WebGLRenderTarget(\n//   mainRenderer.domElement.offsetWidth,\n//   mainRenderer.domElement.offsetHeight,\n//   {\n//     type: HalfFloatType\n//   }\n// );\n// const material = new ShaderMaterial({\n//   uniforms: {\n//     resolution: new Uniform(\n//       new Vector2(\n//         mainRenderer.domElement.offsetWidth,\n//         mainRenderer.domElement.offsetHeight\n//       ).multiplyScalar(\n//         window.devicePixelRatio\n//       )\n//     ),\n//     backNormals: new Uniform(renderTarget.texture),\n//     envMap: new Uniform(CubeTexture.DEFAULT_IMAGE),\n//     refractionIndex: new Uniform(guiOptions.refractionIndex),\n//     color: new Uniform(new Color(guiOptions.color)),\n//     dispersion: new Uniform(guiOptions.dispersion),\n//     roughness: new Uniform(guiOptions.roughness)\n//   },\n//   vertexShader: `\n//   varying vec3 vWorldCameraDir;\n//   varying vec3 vWorldNormal;\n//   varying vec3 vViewNormal;\n//   void main() {\n//     vec4 worldPosition = modelMatrix * vec4( position, 1.0);\n//     vWorldCameraDir = worldPosition.xyz - cameraPosition;\n//     vWorldCameraDir = normalize(vec3(-vWorldCameraDir.x, vWorldCameraDir.yz));\n//     vWorldNormal = (modelMatrix * vec4(normal, 0.0)).xyz;\n//     vWorldNormal = normalize(vec3(-vWorldNormal.x, vWorldNormal.yz));\n// \t\tvViewNormal = normalize( modelViewMatrix * vec4(normal, 0.0)).xyz;\n//   \tgl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n//   }`,\n//   fragmentShader: `\n//   #define REF_WAVELENGTH 579.0\n//   #define RED_WAVELENGTH 650.0\n//   #define GREEN_WAVELENGTH 525.0\n//   #define BLUE_WAVELENGTH 440.0\n//   uniform vec2 resolution;\n//   uniform sampler2D backNormals;\n//   uniform samplerCube envMap;\n//   uniform float refractionIndex;\n//   uniform vec3 color;\n//   uniform float dispersion;\n//   uniform float roughness;\n//   varying vec3 vWorldCameraDir;\n//   varying vec3 vWorldNormal;\n//   varying vec3 vViewNormal;\n//   vec4 refractLight(float wavelength, vec3 backFaceNormal) {\n//     float index = 1.0 / mix(refractionIndex, refractionIndex * REF_WAVELENGTH / wavelength, dispersion);\n//     vec3 dir = vWorldCameraDir;\n//     dir = refract(dir, vWorldNormal, index);\n//     dir = refract(dir, backFaceNormal, index);\n//     return textureCube(envMap, dir);\n//   }\n//   vec3 fresnelSchlick(float cosTheta, vec3 F0)\n//   {\n//     return F0 + (1.0 - F0) * pow(1.0 + cosTheta, 5.0);\n//   }\n//   void main() {\n//     vec3 backFaceNormal = texture2D(backNormals, gl_FragCoord.xy / resolution).rgb;\n//     float r = refractLight(RED_WAVELENGTH, backFaceNormal).r;\n//     float g = refractLight(GREEN_WAVELENGTH, backFaceNormal).g;\n//     float b = refractLight(BLUE_WAVELENGTH, backFaceNormal).b;\n//     vec3 fresnel = fresnelSchlick(dot(vec3(0.0,0.0,-1.0), vViewNormal), vec3(0.04));\n//     vec3 reflectedColor = textureCube(envMap, reflect(vWorldCameraDir, vWorldNormal)).rgb * saturate((1.0 - roughness) + fresnel);\n//     gl_FragColor.rgb = vec3(r,g,b) * color + reflectedColor;\n//   }`\n// });\n// setTimeout(() => {\n//   canvasPlaceSelector.classList.add('rdy');\n// }, 1000);\n// scene.background = new TextureLoader()\n//   .load(\n//     `${themeDir}/build/images/general/resources/cubemap-new/px.png`,\n//   );\n// new CubeTextureLoader()\n//   .setPath(`${themeDir}/build/images/general/resources/test-4/`)\n//   .load(\n//       [\"px.png\", \"nx.png\", \"py.png\", \"ny.png\", \"pz.png\", \"nz.png\"],\n//       (texture) => {\n//         material.uniforms.envMap.value = texture;\n//       }\n//   );\n// window.addEventListener(\"resize\", () => {\n//   renderTarget.setSize(mainRenderer.domElement.offsetWidth, mainRenderer.domElement.offsetHeight);\n//   material.uniforms.resolution.value.set(\n//     window.devicePixelRatio * mainRenderer.domElement.offsetWidth,\n//     window.devicePixelRatio * mainRenderer.domElement.offsetHeight\n//   );\n// });\n// // Animation variables\n// let mixer, mainAnim, action, actionsMap = [], transformAction;\n// let scrollProgressPrecent, time, prevTime;\n// let animationTotalTime,\n//     animCurrentPresent = 0;\n// // Figures variables \n// let trapezoidTopPart, trapezoidBottomPart, \n//     mainCube, pyramid, menu, menuCube, menuParts,\n//     cubeMenuParts;\n// const cubeMenuStep = document.querySelector('[data-hero-step=\"menu\"]');\n// const cubeMenuItems = cubeMenuStep.querySelectorAll('a');\n// new GLTFLoader().load(\n//     `${themeDir}/rdy-2.glb`,\n//     function (gltf) {\n//         const model = gltf.scene;\n//         model.traverse(function(object) {\n//             if (object.isMash) {\n//                 object.castShadow = true;\n//             }\n//         })\n//         console.log('model', model);\n//         // mixer = new THREE.AnimationMixer(model);\n//         // gltf.scene.scale.set(0.0001, 0.0001, 0.0001)\n//         // delete gltf.scene.children[3];\n//         // gltf.scene.translateY(1);\n//         // gltf.scene.translateX(1);\n//         scene.add(gltf.scene);\n//         // console.log('mesh', mesh);\n//         // scene.add(gltf.animations);\n//         const sceneElements = gltf.scene.children[0].children;\n//         console.log('sceneElements', sceneElements);\n//         menu = sceneElements[1];\n//         console.log('menu', menu);\n//         // menu.children[1].visible = false;\n//         pyramid = menu.children[2];\n//         menuParts = menu.children[0];\n//         menuCube = menu.children[1];\n//         console.log('menuParts', menuParts);\n//         cubeMenuParts = menuCube.children.reverse();\n//         cubeMenuParts.shift();\n//         // menu.children[1].visible = false;\n//         // menuParts.children.forEach((part) => {\n//         //   part.material = material;\n//         // })\n//         menuCube.children.forEach((part) => {\n//             part.translateZ(3000)\n//             // part.material.depthFunc = 2;\n//         })\n//         // console.log('pyramid', pyramid);\n//         pyramid.visible = false;\n//         console.log('sceneElements', sceneElements);\n//         // pyramid.children[0].translateZ(100)\n//         // pyramid.children[0].color.set( 0x03fce8 );\n//         const trapezoidObj = sceneElements[2];\n//         // console.log('sceneElements', sceneElements);\n//         // trapezoidObj.children[0].children[0]\n//         trapezoidObj.children[2].visible = false; // hide wrong static element\n//         trapezoidObj.children[0].children[0].material = material;\n//         trapezoidObj.children[0].children[0].children[0].material = material;\n//         trapezoidObj.children[0].children[0].children[1].material = material;\n//         trapezoidObj.children[0].children[1].children[0].material = material;\n//         trapezoidObj.children[0].children[1].children[1].material = material;\n//         trapezoidObj.children[0].children[1].material = material;\n//         trapezoidObj.children[2].children[0].material = material;\n//         trapezoidTopPart = trapezoidObj.children[0];\n//         trapezoidBottomPart = trapezoidObj.children[1];\n//         // trapezoidObj.children[3] = mesh;\n//         mainCube = trapezoidObj.children[3];\n//         mainCube.material.depthTest = true;\n//         mainCube.material.roughness = 0;\n//         mainCube.material.side = 3;\n//         mainCube.material.metalness = 0.5;\n//         console.log('trapezoidObj', trapezoidObj);\n//         mainCube.material = material;\n//         console.log('mainCube', mainCube);\n//         trapezoidTopPart.scale.set(1.01, 1.01, 1.01);\n//         trapezoidTopPart.visible = false;\n//         trapezoidBottomPart.visible = false;\n//         // trapezoidTopPart.material.side = 10;\n//         trapezoidTopPart.children[0].material.depthFunc = 2;\n//         trapezoidBottomPart.children[0].material.depthFunc = 2;\n//         trapezoidTopPart.children[0].material = material;\n//         trapezoidBottomPart.children[0].material = material;\n//         console.log('trapezoidBottomPart', trapezoidBottomPart);\n//         // Camera \n//         // =================================\n//         perspectiveCamera = sceneElements[3];\n//         // Animation \n//         // ================================\n//         mixer = new AnimationMixer( model );\n//         const excludeAnimList = [\n//           // \"Cube1_1.position\",\n//           // \"Cube2_1.position\",\n//         ];\n//         mainAnim = gltf.animations[ 0 ];\n//         mainAnim.tracks = mainAnim.tracks.filter((track) => {\n//             return !excludeAnimList.includes(track.name) ? track : false;\n//         })\n//         animationTotalTime = mainAnim.duration;\n//         //mixer.setTime(9);\n//         action = mixer.clipAction( mainAnim );\n//         // introAction = mixer.clipAction( introAnimationActions );\n//         // transformAction = mixer.clipAction( transformAnimationActions );\n//         // console.log(action.getClip())\n//         // prevAction = { ...action };\n//         // introAction.play();\n//         console.log('mainAnim', mainAnim);\n//         action.play();\n//         animate();\n//         scrollProgressPrecent = (100 * window.scrollY) / maxScrollHeight;\n//         scrollProgressPrecent =\n//             scrollProgressPrecent > 65 && scrollProgressPrecent < 70\n//                 ? 60\n//                 : scrollProgressPrecent;\n//         const time = ((animationTotalTime / 100) * scrollProgressPrecent).toFixed(9);\n//         mixer?.setTime(time);\n//     },\n//     (xhr) => {\n//         console.log((xhr.loaded / xhr.total) * 100 + '% loaded')\n//     },\n//     (error) => {\n//         console.log(error)\n//     }\n// )\n// window.addEventListener('resize', onWindowResize, false)\n// function onWindowResize() {\n//     // camera.aspect = window.innerWidth / window.innerHeight\n//     // camera.updateProjectionMatrix()\n//     perspectiveCamera.aspect = window.innerWidth / window.innerHeight\n//     perspectiveCamera.updateProjectionMatrix()\n//     mainRenderer.setSize(window.innerWidth, window.innerHeight)\n//     render()\n// }\n// const animationProgressHandler = (precent = 0) => {\n//     if (mainAnim !== undefined) {\n//         const time = ((animationTotalTime / 100) * precent).toFixed(9);\n//         mixer?.setTime(time);\n//     }\n// }\n// let isMenuItemMouseInside = false;\n// let hoveredMenuIndex = -1;\n// cubeMenuItems.forEach((item, itemIndex) => {\n//     item.addEventListener('mouseenter', () => {\n//         isMenuItemMouseInside = true;\n//         hoveredMenuIndex = itemIndex;\n//     })\n//     item.addEventListener('mouseleave', () => {\n//         isMenuItemMouseInside = false;\n//         hoveredMenuIndex = -1;\n//     })\n// });\n// window.addEventListener('scroll', () => {\n//     scrollProgressPrecent = (100 * window.scrollY) / maxScrollHeight;\n//     // Play before pause in middle\n//     if (scrollProgressPrecent < 45) {\n//       animationProgressHandler(scrollProgressPrecent);\n//     }\n//     // Pause in middle\n//     if (scrollProgressPrecent > 45 && scrollProgressPrecent < 55) {\n//         !canvasPlaceSelector.matches('.hide') && canvasPlaceSelector.classList.add('hide');\n//     } else {\n//         canvasPlaceSelector.matches('.hide') && canvasPlaceSelector.classList.remove('hide');\n//     }\n//     // Play from paused point\n//     if (scrollProgressPrecent > 55) {\n//       animationProgressHandler(scrollProgressPrecent - 10);\n//     }\n//     // Skip animation part with cube parts movement\n//     if (scrollProgressPrecent > 65) {\n//       animationProgressHandler(60);\n//     }\n//     if (scrollProgressPrecent > 70) {\n//       animationProgressHandler(scrollProgressPrecent + 17);\n//     }\n// })\n// const pointLight = new PointLight(0x30bf9e, 3);\n// const pointLight2 = new PointLight(0xb23cc9, 1);\n// pointLight2.position.x = 0;\n// pointLight2.position.y = 3;\n// pointLight2.position.z = 0;\n// scene.add(pointLight);\n// scene.add(pointLight2);\n// // const hemisphereLight = new HemisphereLight( 0xe8f8fa, 0x080820, 1 );\n// // scene.add( hemisphereLight );\n// const hemisphereLight = new HemisphereLight( 0x03fce8, 0x080820, 1 );\n// scene.add( hemisphereLight );\n// const hemisphereLight_2 = new HemisphereLight( 0x9134af, 0x080820, 1 );\n// scene.add( hemisphereLight_2 );\n// // const directionalLight = new THREE.DirectionalLight( 0x9134af, 0.5 );\n// // scene.add( directionalLight );\n// // const aLight = new THREE.AmbientLight( 0x404040 ); // soft white light\n// // scene.add( aLight );\n// let mouseX = 0, mouseY = 0;\n// document.addEventListener('mousemove', (evt) => {\n//   mouseX = evt.clientX;\n//   mouseY = evt.clientY;\n// })\n// // const clock = new Clock();\n// const changeObjectsByPrecent = (precent) => {\n//     if (precent < 20) {\n//         trapezoidTopPart.visible = false;\n//         trapezoidBottomPart.visible = false;\n//         mainCube.visible = true;\n//     }\n//     if (precent > 20) {\n//         trapezoidTopPart.visible = true;\n//         trapezoidBottomPart.visible = true;\n//         mainCube.visible = false;\n//     }\n//     if (precent > 45) {\n//         trapezoidTopPart.visible = false;\n//         trapezoidBottomPart.visible = false;\n//         mainCube.visible = false;\n//     }\n//     if (precent > 45) {\n//         menu.children[1].visible = true;\n//     } else {\n//         menu.children[1].visible = false;\n//     }\n//     if (precent > 50) {\n//         pyramid.visible = true;\n//     } else {\n//         pyramid.visible = false;\n//     }\n// }\n// const translateValue = 40;\n// const menuItemsTransitionHanlder = () => {\n//     for (let i = 0; i <= cubeMenuItems.length - 1; i++) {\n//         if (isMenuItemMouseInside && i == hoveredMenuIndex) {\n//             if (cubeMenuParts[hoveredMenuIndex].position.z < translateValue) {\n//                 cubeMenuParts[hoveredMenuIndex].position.z += 2;\n//             }\n//         }\n//         if (cubeMenuParts[i].position.z > 0 && i !== hoveredMenuIndex) {\n//             cubeMenuParts[i].position.z -= 2;\n//         }\n//     }\n// }\n// function animate() {\n//     animCurrentPresent = (action.time * 100) / animationTotalTime;\n//     changeObjectsByPrecent(animCurrentPresent);\n//     menuItemsTransitionHanlder();\n//     mainCube.rotation.y -= 0.005;\n//     mainCube.rotation.x -= 0.005;\n//     mainCube.rotation.z -= 0.005;\n//     perspectiveCamera.aspect = window.innerWidth / window.innerHeight\n//     perspectiveCamera.updateProjectionMatrix()\n//     mainRenderer.render(scene, perspectiveCamera)\n//     requestAnimationFrame(animate);\n// }\n// function render() {\n//     mainRenderer.render(scene,  perspectiveCamera)\n// }\n\n//# sourceURL=webpack://start-template/./dev/static/js/index.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./dev/static/js/index.js"]();
/******/ 	
/******/ })()
;